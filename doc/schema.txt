YAML Schema Reference
=====================

Propel Behaviors
----------------

Enable native Propel behaviors in your tables by setting the `_propel_behaviors` key. For instance, to turn on `soft_delete` on an `Article` table, write the following schema: 

    [yaml]
    propel:
      article:
        _attributes: { phpName: Article }
        id:          ~
        title:       varchar(150)
        body:        longvarchar
        _propel_behaviors:
          soft_delete:

Here is the list of Propel core behaviors available in this plugin: 

- [timestampable](http://www.propelorm.org/wiki/Documentation/1.5/Behaviors/timestampable): Keep track of the creation and modification date of each record.
- [sluggable](http://www.propelorm.org/wiki/Documentation/1.5/Behaviors/sluggable): Each row gets a unique slug that you can use to make smart URIs
- [soft_delete]([http://www.propelorm.org/wiki/Documentation/1.5/Behaviors/soft_delete): Keep the deleted rows hidden, so that you can recover them.
- [nested_set](http://www.propelorm.org/wiki/Documentation/1.5/Behaviors/nested_set): Handle hierarchichal data with ease; the nested sets algorithm needs only one query to parse a tree in any way.
- [sortable](http://www.propelorm.org/wiki/Documentation/1.5/Behaviors/sortable): Give rows in a table the ability to be moved up and down of a list, and to retrieve sorted results. 
- [concrete_inheritance](http://www.propelorm.org/wiki/Documentation/1.5/Inheritance#ConcreteTableInheritance): Copy the structure of a model class to another; also copy the data back to the parent class, for efficient queries.
- [query_cache](http://www.propelorm.org/wiki/Documentation/1.5/Behaviors/query_cache): Speed up often used queries by skipping the query analysis process. Propel will still query the database for results, only faster.
- [alternative_coding_standards](http://www.propelorm.org/xiki/Documentation/1.5/Behaviors/alternative_coding_standards): Use symfony's coding standards in Propel's generated classes.
- [auto_add_pk](http://www.propelorm.org/wiki/Documentation/1.5/Behaviors/auto_add_pk): Classes that don't have a primary key get one.

You can register more than one behavior and set the parameters of each behaviors:

    [yaml]
    propel:
      article:
        _attributes: { phpName: Article }
        id:          ~
        title:       varchar(150)
        body:        longvarchar
        deleted_on:  timestamp
        _propel_behaviors:
          soft_delete: { deleted_column: deleted_on }
          sluggable:
          timestampable:

You can also register a behavior for all your models right in the `propel.ini`. `sfPropel15Plugin` already enables the `symfony` and `symfony_i18n` behaviors to support symfony's behavior system and model localization features, but you can easily add your owns:

    [ini]
    propel.behavior.default = symfony,symfony_i18n,alternative_coding_standards,auto_add_pk

**Tip**: Beware not to mix up native propel behaviors, documented in the Propel core, with symfony behaviors for Propel. Native propel behaviors are faster and more powerful, because they are executed at buildtime and not at runtime. Symfony behaviors for Propel, that usually require an additional plugin, are registered under the `_behaviors` key.

Single Table Inheritance
------------------------

To enable single table inheritance in a table, define a type column, and add the `_inheritance` key, as follows:

    [yaml]
    propel:
      person:
        _attributes: { phpName: Person }
        id:          ~
        name:        varchar(100)
        type:        varchar(20)
        _inheritance:
          column:    type
          classes:
            type_1:  Employee
            type_2:  Manager

The keys used in the `classes` hash define the value given to the inheritance column in the database, while the value determine the actual class names.

Such a schema will generate both a Model and a Query class for `Employee` and `Manager`, in addition to the ones generated for `Person`:

    model/
      Person.php
      PersonPeer.php
      PersonQuery.php
      Employee.php
      EmployeeQuery.php
      Manager.php
      ManagerQuery.php
      
A `PersonQuery` returns mixed results, of class `Person`, `Employee`, and `Manager`, while a `ManagerQuery` returns only objects of class `Manager`:

    [php]
    $person = new Person();
    $person->setName('John');
    $person->save();
    $manager = new Manager();
    $manager->setName('Jack');
    $manager->save();
    echo PersonQuery::create()->count();  // 2
    echo ManagerQuery::create()->count(); // 1

Relation Names
--------------

When you define a foreign key, Propel creates a relationship. Both the objects involved in the relationship see it with a different name. By default, the relation name is the phpName of the related object. For instance, for a `user_id` foreign key in a `book` table:

    [yaml]
    propel:
      user:
        _attributes: { phpName: User }
        id:          ~
        first_name:  varchar(100)
        last_name:   varchar(100)
      book:
        _attributes: { phpName: Book }
        id:          ~
        title:       varchar(150)
        body:        longvarchar
        user_id:     { type: integer, foreignTable: user, foreignReference: id, onDelete: cascade }

Here, Propel creates a `User` relation on the `Book` object, and a `Book` relation on the `User` object. These relations are used to forge the foreign object getters and setters in the Model object, as well as the foreign object filters in the Query object:

    [php]
    $user = $book->getUser();
    $user = UserQuery::create()
      ->filterByBook($book)
      ->findOne();
    $books = $user->getBooks();
    $books = BookQuery::create()
      ->filterByUser($user)
      ->find();

You may want to customize the relation names to qualify the relationship. In the previous example, when related to an `Article`, a `User` would better be called an `Author`. Symmetrically, from the `User` point of view, a `Book` should be named a `Work`. Use the `fkPhpName` and `fkRefPhpName` column attributes to choose custom relation names:

[yaml]
propel:
  article:
    _attributes: { phpName: Article }
    id:          ~
    title:       varchar(150)
    body:        longvarchar
    user_id:     { fkPhpName: Author, fkRefPhpName: Work, type: integer, foreignTable: user, foreignReference: id, onDelete: cascade }

Now the generated code looks like this:

    [php]
    $user = $book->getAuthor();
    $user = UserQuery::create()
      ->filterByWork($book)
      ->findOne();
    $books = $user->getWorks();
    $books = BookQuery::create()
      ->filterByAuthor($user)
      ->find();

The ability to name both sides of a relationship becomes very handy when you have to deal with several foreign keys to the same table.

Custom BaseObject
-----------------

By default, the generated Model objects extend BaseObject. You can customize this parent class on a per table basis by overriding the `baseClass` attribute:

    [yaml]
    propel:
      person:
        _attributes: { phpName: Person, baseClass: myBaseObject }
        id:          ~
        name:        varchar(100)
        type:        varchar(20)

A `build-model` will then produce:

    [php]
    class Person extends BasePerson
    abstract class BasePerson extends myBaseObject
